// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "net.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace {

const ::google::protobuf::Descriptor* NetParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NetParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* TensorParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TensorParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* LayerParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  LayerParams_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* LayerParams_LayerType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* FullyConnectedParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FullyConnectedParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* ConvolutionalParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  ConvolutionalParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* PoolingParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  PoolingParams_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* PoolingParams_PoolingType_descriptor_ = NULL;
const ::google::protobuf::Descriptor* SoftmaxParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SoftmaxParams_reflection_ = NULL;
const ::google::protobuf::Descriptor* CrossEntropyParams_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  CrossEntropyParams_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_net_2eproto() {
  protobuf_AddDesc_net_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "net.proto");
  GOOGLE_CHECK(file != NULL);
  NetParams_descriptor_ = file->message_type(0);
  static const int NetParams_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetParams, layer_),
  };
  NetParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NetParams_descriptor_,
      NetParams::default_instance_,
      NetParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NetParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NetParams));
  TensorParams_descriptor_ = file->message_type(1);
  static const int TensorParams_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorParams, shape_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorParams, weights_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorParams, bias_),
  };
  TensorParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      TensorParams_descriptor_,
      TensorParams::default_instance_,
      TensorParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TensorParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(TensorParams));
  LayerParams_descriptor_ = file->message_type(2);
  static const int LayerParams_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, name_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, bottom_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, top_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, weights_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, fully_connected_params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, convolutional_params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, pooling_params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, softmax_params_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, cross_entropy_params_),
  };
  LayerParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      LayerParams_descriptor_,
      LayerParams::default_instance_,
      LayerParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(LayerParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(LayerParams));
  LayerParams_LayerType_descriptor_ = LayerParams_descriptor_->enum_type(0);
  FullyConnectedParams_descriptor_ = file->message_type(3);
  static const int FullyConnectedParams_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FullyConnectedParams, output_),
  };
  FullyConnectedParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FullyConnectedParams_descriptor_,
      FullyConnectedParams::default_instance_,
      FullyConnectedParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FullyConnectedParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FullyConnectedParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FullyConnectedParams));
  ConvolutionalParams_descriptor_ = file->message_type(4);
  static const int ConvolutionalParams_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalParams, kernel_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalParams, stride_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalParams, features_maps_),
  };
  ConvolutionalParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      ConvolutionalParams_descriptor_,
      ConvolutionalParams::default_instance_,
      ConvolutionalParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(ConvolutionalParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(ConvolutionalParams));
  PoolingParams_descriptor_ = file->message_type(5);
  static const int PoolingParams_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoolingParams, type_),
  };
  PoolingParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      PoolingParams_descriptor_,
      PoolingParams::default_instance_,
      PoolingParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoolingParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(PoolingParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(PoolingParams));
  PoolingParams_PoolingType_descriptor_ = PoolingParams_descriptor_->enum_type(0);
  SoftmaxParams_descriptor_ = file->message_type(6);
  static const int SoftmaxParams_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftmaxParams, output_),
  };
  SoftmaxParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      SoftmaxParams_descriptor_,
      SoftmaxParams::default_instance_,
      SoftmaxParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftmaxParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SoftmaxParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(SoftmaxParams));
  CrossEntropyParams_descriptor_ = file->message_type(7);
  static const int CrossEntropyParams_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossEntropyParams, output_),
  };
  CrossEntropyParams_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      CrossEntropyParams_descriptor_,
      CrossEntropyParams::default_instance_,
      CrossEntropyParams_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossEntropyParams, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(CrossEntropyParams, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(CrossEntropyParams));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_net_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NetParams_descriptor_, &NetParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    TensorParams_descriptor_, &TensorParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    LayerParams_descriptor_, &LayerParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FullyConnectedParams_descriptor_, &FullyConnectedParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    ConvolutionalParams_descriptor_, &ConvolutionalParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    PoolingParams_descriptor_, &PoolingParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    SoftmaxParams_descriptor_, &SoftmaxParams::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    CrossEntropyParams_descriptor_, &CrossEntropyParams::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_net_2eproto() {
  delete NetParams::default_instance_;
  delete NetParams_reflection_;
  delete TensorParams::default_instance_;
  delete TensorParams_reflection_;
  delete LayerParams::default_instance_;
  delete LayerParams_reflection_;
  delete FullyConnectedParams::default_instance_;
  delete FullyConnectedParams_reflection_;
  delete ConvolutionalParams::default_instance_;
  delete ConvolutionalParams_reflection_;
  delete PoolingParams::default_instance_;
  delete PoolingParams_reflection_;
  delete SoftmaxParams::default_instance_;
  delete SoftmaxParams_reflection_;
  delete CrossEntropyParams::default_instance_;
  delete CrossEntropyParams_reflection_;
}

void protobuf_AddDesc_net_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\tnet.proto\"(\n\tNetParams\022\033\n\005layer\030\001 \003(\0132"
    "\014.LayerParams\"<\n\014TensorParams\022\r\n\005shape\030\001"
    " \003(\005\022\017\n\007weights\030\002 \003(\001\022\014\n\004bias\030\003 \003(\001\"\357\003\n\013"
    "LayerParams\022\014\n\004name\030\001 \002(\t\022\016\n\006bottom\030\002 \002("
    "\t\022\013\n\003top\030\003 \002(\t\022$\n\004type\030\004 \002(\0162\026.LayerPara"
    "ms.LayerType\022\036\n\007weights\030\005 \003(\0132\r.TensorPa"
    "rams\0225\n\026fully_connected_params\030\006 \001(\0132\025.F"
    "ullyConnectedParams\0222\n\024convolutional_par"
    "ams\030\007 \001(\0132\024.ConvolutionalParams\022&\n\016pooli"
    "ng_params\030\010 \001(\0132\016.PoolingParams\022&\n\016softm"
    "ax_params\030\t \001(\0132\016.SoftmaxParams\0221\n\024cross"
    "_entropy_params\030\n \001(\0132\023.CrossEntropyPara"
    "ms\"\200\001\n\tLayerType\022\023\n\017FULLY_CONNECTED\020\001\022\010\n"
    "\004RELU\020\002\022\013\n\007SIGMOID\020\003\022\021\n\rCONVOLUTIONAL\020\004\022"
    "\020\n\014SOFTMAX_LOSS\020\005\022\025\n\021CROSSENTROPY_LOSS\020\006"
    "\022\013\n\007POOLING\020\007\"&\n\024FullyConnectedParams\022\016\n"
    "\006output\030\001 \002(\005\"Q\n\023ConvolutionalParams\022\023\n\013"
    "kernel_size\030\001 \002(\005\022\016\n\006stride\030\002 \002(\005\022\025\n\rfea"
    "tures_maps\030\003 \002(\005\"Z\n\rPoolingParams\022(\n\004typ"
    "e\030\001 \002(\0162\032.PoolingParams.PoolingType\"\037\n\013P"
    "oolingType\022\007\n\003MAX\020\001\022\007\n\003AVG\020\002\"\037\n\rSoftmaxP"
    "arams\022\016\n\006output\030\001 \002(\005\"$\n\022CrossEntropyPar"
    "ams\022\016\n\006output\030\001 \002(\005", 899);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "net.proto", &protobuf_RegisterTypes);
  NetParams::default_instance_ = new NetParams();
  TensorParams::default_instance_ = new TensorParams();
  LayerParams::default_instance_ = new LayerParams();
  FullyConnectedParams::default_instance_ = new FullyConnectedParams();
  ConvolutionalParams::default_instance_ = new ConvolutionalParams();
  PoolingParams::default_instance_ = new PoolingParams();
  SoftmaxParams::default_instance_ = new SoftmaxParams();
  CrossEntropyParams::default_instance_ = new CrossEntropyParams();
  NetParams::default_instance_->InitAsDefaultInstance();
  TensorParams::default_instance_->InitAsDefaultInstance();
  LayerParams::default_instance_->InitAsDefaultInstance();
  FullyConnectedParams::default_instance_->InitAsDefaultInstance();
  ConvolutionalParams::default_instance_->InitAsDefaultInstance();
  PoolingParams::default_instance_->InitAsDefaultInstance();
  SoftmaxParams::default_instance_->InitAsDefaultInstance();
  CrossEntropyParams::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_net_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_net_2eproto {
  StaticDescriptorInitializer_net_2eproto() {
    protobuf_AddDesc_net_2eproto();
  }
} static_descriptor_initializer_net_2eproto_;

// ===================================================================

#ifndef _MSC_VER
const int NetParams::kLayerFieldNumber;
#endif  // !_MSC_VER

NetParams::NetParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NetParams::InitAsDefaultInstance() {
}

NetParams::NetParams(const NetParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NetParams::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NetParams::~NetParams() {
  SharedDtor();
}

void NetParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NetParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NetParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NetParams_descriptor_;
}

const NetParams& NetParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

NetParams* NetParams::default_instance_ = NULL;

NetParams* NetParams::New() const {
  return new NetParams;
}

void NetParams::Clear() {
  layer_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NetParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .LayerParams layer = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_layer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_layer()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_layer;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NetParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .LayerParams layer = 1;
  for (int i = 0; i < this->layer_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->layer(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NetParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .LayerParams layer = 1;
  for (int i = 0; i < this->layer_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->layer(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NetParams::ByteSize() const {
  int total_size = 0;

  // repeated .LayerParams layer = 1;
  total_size += 1 * this->layer_size();
  for (int i = 0; i < this->layer_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->layer(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NetParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NetParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NetParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NetParams::MergeFrom(const NetParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  layer_.MergeFrom(from.layer_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NetParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NetParams::CopyFrom(const NetParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NetParams::IsInitialized() const {

  for (int i = 0; i < layer_size(); i++) {
    if (!this->layer(i).IsInitialized()) return false;
  }
  return true;
}

void NetParams::Swap(NetParams* other) {
  if (other != this) {
    layer_.Swap(&other->layer_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NetParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NetParams_descriptor_;
  metadata.reflection = NetParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int TensorParams::kShapeFieldNumber;
const int TensorParams::kWeightsFieldNumber;
const int TensorParams::kBiasFieldNumber;
#endif  // !_MSC_VER

TensorParams::TensorParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void TensorParams::InitAsDefaultInstance() {
}

TensorParams::TensorParams(const TensorParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void TensorParams::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

TensorParams::~TensorParams() {
  SharedDtor();
}

void TensorParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void TensorParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TensorParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TensorParams_descriptor_;
}

const TensorParams& TensorParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

TensorParams* TensorParams::default_instance_ = NULL;

TensorParams* TensorParams::New() const {
  return new TensorParams;
}

void TensorParams::Clear() {
  shape_.Clear();
  weights_.Clear();
  bias_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool TensorParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated int32 shape = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_shape:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 1, 8, input, this->mutable_shape())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, this->mutable_shape())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(8)) goto parse_shape;
        if (input->ExpectTag(17)) goto parse_weights;
        break;
      }

      // repeated double weights = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_weights:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 17, input, this->mutable_weights())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_weights())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_weights;
        if (input->ExpectTag(25)) goto parse_bias;
        break;
      }

      // repeated double bias = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_bias:
          DO_((::google::protobuf::internal::WireFormatLite::ReadRepeatedPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 1, 25, input, this->mutable_bias())));
        } else if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag)
                   == ::google::protobuf::internal::WireFormatLite::
                      WIRETYPE_LENGTH_DELIMITED) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPackedPrimitiveNoInline<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, this->mutable_bias())));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_bias;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void TensorParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated int32 shape = 1;
  for (int i = 0; i < this->shape_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(
      1, this->shape(i), output);
  }

  // repeated double weights = 2;
  for (int i = 0; i < this->weights_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      2, this->weights(i), output);
  }

  // repeated double bias = 3;
  for (int i = 0; i < this->bias_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(
      3, this->bias(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* TensorParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated int32 shape = 1;
  for (int i = 0; i < this->shape_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteInt32ToArray(1, this->shape(i), target);
  }

  // repeated double weights = 2;
  for (int i = 0; i < this->weights_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(2, this->weights(i), target);
  }

  // repeated double bias = 3;
  for (int i = 0; i < this->bias_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteDoubleToArray(3, this->bias(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int TensorParams::ByteSize() const {
  int total_size = 0;

  // repeated int32 shape = 1;
  {
    int data_size = 0;
    for (int i = 0; i < this->shape_size(); i++) {
      data_size += ::google::protobuf::internal::WireFormatLite::
        Int32Size(this->shape(i));
    }
    total_size += 1 * this->shape_size() + data_size;
  }

  // repeated double weights = 2;
  {
    int data_size = 0;
    data_size = 8 * this->weights_size();
    total_size += 1 * this->weights_size() + data_size;
  }

  // repeated double bias = 3;
  {
    int data_size = 0;
    data_size = 8 * this->bias_size();
    total_size += 1 * this->bias_size() + data_size;
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TensorParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const TensorParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const TensorParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void TensorParams::MergeFrom(const TensorParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  shape_.MergeFrom(from.shape_);
  weights_.MergeFrom(from.weights_);
  bias_.MergeFrom(from.bias_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void TensorParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TensorParams::CopyFrom(const TensorParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TensorParams::IsInitialized() const {

  return true;
}

void TensorParams::Swap(TensorParams* other) {
  if (other != this) {
    shape_.Swap(&other->shape_);
    weights_.Swap(&other->weights_);
    bias_.Swap(&other->bias_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata TensorParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TensorParams_descriptor_;
  metadata.reflection = TensorParams_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* LayerParams_LayerType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LayerParams_LayerType_descriptor_;
}
bool LayerParams_LayerType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
    case 7:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const LayerParams_LayerType LayerParams::FULLY_CONNECTED;
const LayerParams_LayerType LayerParams::RELU;
const LayerParams_LayerType LayerParams::SIGMOID;
const LayerParams_LayerType LayerParams::CONVOLUTIONAL;
const LayerParams_LayerType LayerParams::SOFTMAX_LOSS;
const LayerParams_LayerType LayerParams::CROSSENTROPY_LOSS;
const LayerParams_LayerType LayerParams::POOLING;
const LayerParams_LayerType LayerParams::LayerType_MIN;
const LayerParams_LayerType LayerParams::LayerType_MAX;
const int LayerParams::LayerType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int LayerParams::kNameFieldNumber;
const int LayerParams::kBottomFieldNumber;
const int LayerParams::kTopFieldNumber;
const int LayerParams::kTypeFieldNumber;
const int LayerParams::kWeightsFieldNumber;
const int LayerParams::kFullyConnectedParamsFieldNumber;
const int LayerParams::kConvolutionalParamsFieldNumber;
const int LayerParams::kPoolingParamsFieldNumber;
const int LayerParams::kSoftmaxParamsFieldNumber;
const int LayerParams::kCrossEntropyParamsFieldNumber;
#endif  // !_MSC_VER

LayerParams::LayerParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void LayerParams::InitAsDefaultInstance() {
  fully_connected_params_ = const_cast< ::FullyConnectedParams*>(&::FullyConnectedParams::default_instance());
  convolutional_params_ = const_cast< ::ConvolutionalParams*>(&::ConvolutionalParams::default_instance());
  pooling_params_ = const_cast< ::PoolingParams*>(&::PoolingParams::default_instance());
  softmax_params_ = const_cast< ::SoftmaxParams*>(&::SoftmaxParams::default_instance());
  cross_entropy_params_ = const_cast< ::CrossEntropyParams*>(&::CrossEntropyParams::default_instance());
}

LayerParams::LayerParams(const LayerParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void LayerParams::SharedCtor() {
  _cached_size_ = 0;
  name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  bottom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  top_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  type_ = 1;
  fully_connected_params_ = NULL;
  convolutional_params_ = NULL;
  pooling_params_ = NULL;
  softmax_params_ = NULL;
  cross_entropy_params_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

LayerParams::~LayerParams() {
  SharedDtor();
}

void LayerParams::SharedDtor() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (bottom_ != &::google::protobuf::internal::kEmptyString) {
    delete bottom_;
  }
  if (top_ != &::google::protobuf::internal::kEmptyString) {
    delete top_;
  }
  if (this != default_instance_) {
    delete fully_connected_params_;
    delete convolutional_params_;
    delete pooling_params_;
    delete softmax_params_;
    delete cross_entropy_params_;
  }
}

void LayerParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* LayerParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return LayerParams_descriptor_;
}

const LayerParams& LayerParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

LayerParams* LayerParams::default_instance_ = NULL;

LayerParams* LayerParams::New() const {
  return new LayerParams;
}

void LayerParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_name()) {
      if (name_ != &::google::protobuf::internal::kEmptyString) {
        name_->clear();
      }
    }
    if (has_bottom()) {
      if (bottom_ != &::google::protobuf::internal::kEmptyString) {
        bottom_->clear();
      }
    }
    if (has_top()) {
      if (top_ != &::google::protobuf::internal::kEmptyString) {
        top_->clear();
      }
    }
    type_ = 1;
    if (has_fully_connected_params()) {
      if (fully_connected_params_ != NULL) fully_connected_params_->::FullyConnectedParams::Clear();
    }
    if (has_convolutional_params()) {
      if (convolutional_params_ != NULL) convolutional_params_->::ConvolutionalParams::Clear();
    }
    if (has_pooling_params()) {
      if (pooling_params_ != NULL) pooling_params_->::PoolingParams::Clear();
    }
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (has_softmax_params()) {
      if (softmax_params_ != NULL) softmax_params_->::SoftmaxParams::Clear();
    }
    if (has_cross_entropy_params()) {
      if (cross_entropy_params_ != NULL) cross_entropy_params_->::CrossEntropyParams::Clear();
    }
  }
  weights_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool LayerParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string name = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_name()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->name().data(), this->name().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_bottom;
        break;
      }

      // required string bottom = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_bottom:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_bottom()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->bottom().data(), this->bottom().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_top;
        break;
      }

      // required string top = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_top:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_top()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->top().data(), this->top().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(32)) goto parse_type;
        break;
      }

      // required .LayerParams.LayerType type = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_type:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::LayerParams_LayerType_IsValid(value)) {
            set_type(static_cast< ::LayerParams_LayerType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(4, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_weights;
        break;
      }

      // repeated .TensorParams weights = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_weights:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_weights()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_weights;
        if (input->ExpectTag(50)) goto parse_fully_connected_params;
        break;
      }

      // optional .FullyConnectedParams fully_connected_params = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_fully_connected_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_fully_connected_params()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_convolutional_params;
        break;
      }

      // optional .ConvolutionalParams convolutional_params = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_convolutional_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_convolutional_params()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(66)) goto parse_pooling_params;
        break;
      }

      // optional .PoolingParams pooling_params = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_pooling_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_pooling_params()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(74)) goto parse_softmax_params;
        break;
      }

      // optional .SoftmaxParams softmax_params = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_softmax_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_softmax_params()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(82)) goto parse_cross_entropy_params;
        break;
      }

      // optional .CrossEntropyParams cross_entropy_params = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_cross_entropy_params:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_cross_entropy_params()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void LayerParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->name(), output);
  }

  // required string bottom = 2;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bottom().data(), this->bottom().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->bottom(), output);
  }

  // required string top = 3;
  if (has_top()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->top().data(), this->top().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->top(), output);
  }

  // required .LayerParams.LayerType type = 4;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      4, this->type(), output);
  }

  // repeated .TensorParams weights = 5;
  for (int i = 0; i < this->weights_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      5, this->weights(i), output);
  }

  // optional .FullyConnectedParams fully_connected_params = 6;
  if (has_fully_connected_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      6, this->fully_connected_params(), output);
  }

  // optional .ConvolutionalParams convolutional_params = 7;
  if (has_convolutional_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      7, this->convolutional_params(), output);
  }

  // optional .PoolingParams pooling_params = 8;
  if (has_pooling_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      8, this->pooling_params(), output);
  }

  // optional .SoftmaxParams softmax_params = 9;
  if (has_softmax_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      9, this->softmax_params(), output);
  }

  // optional .CrossEntropyParams cross_entropy_params = 10;
  if (has_cross_entropy_params()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      10, this->cross_entropy_params(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* LayerParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string name = 1;
  if (has_name()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->name().data(), this->name().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->name(), target);
  }

  // required string bottom = 2;
  if (has_bottom()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->bottom().data(), this->bottom().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->bottom(), target);
  }

  // required string top = 3;
  if (has_top()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->top().data(), this->top().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->top(), target);
  }

  // required .LayerParams.LayerType type = 4;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      4, this->type(), target);
  }

  // repeated .TensorParams weights = 5;
  for (int i = 0; i < this->weights_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        5, this->weights(i), target);
  }

  // optional .FullyConnectedParams fully_connected_params = 6;
  if (has_fully_connected_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        6, this->fully_connected_params(), target);
  }

  // optional .ConvolutionalParams convolutional_params = 7;
  if (has_convolutional_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        7, this->convolutional_params(), target);
  }

  // optional .PoolingParams pooling_params = 8;
  if (has_pooling_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        8, this->pooling_params(), target);
  }

  // optional .SoftmaxParams softmax_params = 9;
  if (has_softmax_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        9, this->softmax_params(), target);
  }

  // optional .CrossEntropyParams cross_entropy_params = 10;
  if (has_cross_entropy_params()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        10, this->cross_entropy_params(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int LayerParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string name = 1;
    if (has_name()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->name());
    }

    // required string bottom = 2;
    if (has_bottom()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->bottom());
    }

    // required string top = 3;
    if (has_top()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->top());
    }

    // required .LayerParams.LayerType type = 4;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // optional .FullyConnectedParams fully_connected_params = 6;
    if (has_fully_connected_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->fully_connected_params());
    }

    // optional .ConvolutionalParams convolutional_params = 7;
    if (has_convolutional_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->convolutional_params());
    }

    // optional .PoolingParams pooling_params = 8;
    if (has_pooling_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->pooling_params());
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // optional .SoftmaxParams softmax_params = 9;
    if (has_softmax_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->softmax_params());
    }

    // optional .CrossEntropyParams cross_entropy_params = 10;
    if (has_cross_entropy_params()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->cross_entropy_params());
    }

  }
  // repeated .TensorParams weights = 5;
  total_size += 1 * this->weights_size();
  for (int i = 0; i < this->weights_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->weights(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void LayerParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const LayerParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const LayerParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void LayerParams::MergeFrom(const LayerParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  weights_.MergeFrom(from.weights_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_name()) {
      set_name(from.name());
    }
    if (from.has_bottom()) {
      set_bottom(from.bottom());
    }
    if (from.has_top()) {
      set_top(from.top());
    }
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_fully_connected_params()) {
      mutable_fully_connected_params()->::FullyConnectedParams::MergeFrom(from.fully_connected_params());
    }
    if (from.has_convolutional_params()) {
      mutable_convolutional_params()->::ConvolutionalParams::MergeFrom(from.convolutional_params());
    }
    if (from.has_pooling_params()) {
      mutable_pooling_params()->::PoolingParams::MergeFrom(from.pooling_params());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_softmax_params()) {
      mutable_softmax_params()->::SoftmaxParams::MergeFrom(from.softmax_params());
    }
    if (from.has_cross_entropy_params()) {
      mutable_cross_entropy_params()->::CrossEntropyParams::MergeFrom(from.cross_entropy_params());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void LayerParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void LayerParams::CopyFrom(const LayerParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool LayerParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000f) != 0x0000000f) return false;

  if (has_fully_connected_params()) {
    if (!this->fully_connected_params().IsInitialized()) return false;
  }
  if (has_convolutional_params()) {
    if (!this->convolutional_params().IsInitialized()) return false;
  }
  if (has_pooling_params()) {
    if (!this->pooling_params().IsInitialized()) return false;
  }
  if (has_softmax_params()) {
    if (!this->softmax_params().IsInitialized()) return false;
  }
  if (has_cross_entropy_params()) {
    if (!this->cross_entropy_params().IsInitialized()) return false;
  }
  return true;
}

void LayerParams::Swap(LayerParams* other) {
  if (other != this) {
    std::swap(name_, other->name_);
    std::swap(bottom_, other->bottom_);
    std::swap(top_, other->top_);
    std::swap(type_, other->type_);
    weights_.Swap(&other->weights_);
    std::swap(fully_connected_params_, other->fully_connected_params_);
    std::swap(convolutional_params_, other->convolutional_params_);
    std::swap(pooling_params_, other->pooling_params_);
    std::swap(softmax_params_, other->softmax_params_);
    std::swap(cross_entropy_params_, other->cross_entropy_params_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata LayerParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = LayerParams_descriptor_;
  metadata.reflection = LayerParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FullyConnectedParams::kOutputFieldNumber;
#endif  // !_MSC_VER

FullyConnectedParams::FullyConnectedParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FullyConnectedParams::InitAsDefaultInstance() {
}

FullyConnectedParams::FullyConnectedParams(const FullyConnectedParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FullyConnectedParams::SharedCtor() {
  _cached_size_ = 0;
  output_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FullyConnectedParams::~FullyConnectedParams() {
  SharedDtor();
}

void FullyConnectedParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void FullyConnectedParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FullyConnectedParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FullyConnectedParams_descriptor_;
}

const FullyConnectedParams& FullyConnectedParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

FullyConnectedParams* FullyConnectedParams::default_instance_ = NULL;

FullyConnectedParams* FullyConnectedParams::New() const {
  return new FullyConnectedParams;
}

void FullyConnectedParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    output_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FullyConnectedParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 output = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &output_)));
          set_has_output();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FullyConnectedParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 output = 1;
  if (has_output()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->output(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FullyConnectedParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 output = 1;
  if (has_output()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->output(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FullyConnectedParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 output = 1;
    if (has_output()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->output());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FullyConnectedParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FullyConnectedParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FullyConnectedParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FullyConnectedParams::MergeFrom(const FullyConnectedParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_output()) {
      set_output(from.output());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FullyConnectedParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FullyConnectedParams::CopyFrom(const FullyConnectedParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FullyConnectedParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void FullyConnectedParams::Swap(FullyConnectedParams* other) {
  if (other != this) {
    std::swap(output_, other->output_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FullyConnectedParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FullyConnectedParams_descriptor_;
  metadata.reflection = FullyConnectedParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int ConvolutionalParams::kKernelSizeFieldNumber;
const int ConvolutionalParams::kStrideFieldNumber;
const int ConvolutionalParams::kFeaturesMapsFieldNumber;
#endif  // !_MSC_VER

ConvolutionalParams::ConvolutionalParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void ConvolutionalParams::InitAsDefaultInstance() {
}

ConvolutionalParams::ConvolutionalParams(const ConvolutionalParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void ConvolutionalParams::SharedCtor() {
  _cached_size_ = 0;
  kernel_size_ = 0;
  stride_ = 0;
  features_maps_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

ConvolutionalParams::~ConvolutionalParams() {
  SharedDtor();
}

void ConvolutionalParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void ConvolutionalParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* ConvolutionalParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ConvolutionalParams_descriptor_;
}

const ConvolutionalParams& ConvolutionalParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

ConvolutionalParams* ConvolutionalParams::default_instance_ = NULL;

ConvolutionalParams* ConvolutionalParams::New() const {
  return new ConvolutionalParams;
}

void ConvolutionalParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    kernel_size_ = 0;
    stride_ = 0;
    features_maps_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool ConvolutionalParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 kernel_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &kernel_size_)));
          set_has_kernel_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(16)) goto parse_stride;
        break;
      }

      // required int32 stride = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_stride:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &stride_)));
          set_has_stride();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(24)) goto parse_features_maps;
        break;
      }

      // required int32 features_maps = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_features_maps:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &features_maps_)));
          set_has_features_maps();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void ConvolutionalParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 kernel_size = 1;
  if (has_kernel_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->kernel_size(), output);
  }

  // required int32 stride = 2;
  if (has_stride()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(2, this->stride(), output);
  }

  // required int32 features_maps = 3;
  if (has_features_maps()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(3, this->features_maps(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* ConvolutionalParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 kernel_size = 1;
  if (has_kernel_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->kernel_size(), target);
  }

  // required int32 stride = 2;
  if (has_stride()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(2, this->stride(), target);
  }

  // required int32 features_maps = 3;
  if (has_features_maps()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(3, this->features_maps(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int ConvolutionalParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 kernel_size = 1;
    if (has_kernel_size()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->kernel_size());
    }

    // required int32 stride = 2;
    if (has_stride()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->stride());
    }

    // required int32 features_maps = 3;
    if (has_features_maps()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->features_maps());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void ConvolutionalParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const ConvolutionalParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const ConvolutionalParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void ConvolutionalParams::MergeFrom(const ConvolutionalParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_kernel_size()) {
      set_kernel_size(from.kernel_size());
    }
    if (from.has_stride()) {
      set_stride(from.stride());
    }
    if (from.has_features_maps()) {
      set_features_maps(from.features_maps());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void ConvolutionalParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void ConvolutionalParams::CopyFrom(const ConvolutionalParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ConvolutionalParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void ConvolutionalParams::Swap(ConvolutionalParams* other) {
  if (other != this) {
    std::swap(kernel_size_, other->kernel_size_);
    std::swap(stride_, other->stride_);
    std::swap(features_maps_, other->features_maps_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata ConvolutionalParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = ConvolutionalParams_descriptor_;
  metadata.reflection = ConvolutionalParams_reflection_;
  return metadata;
}


// ===================================================================

const ::google::protobuf::EnumDescriptor* PoolingParams_PoolingType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PoolingParams_PoolingType_descriptor_;
}
bool PoolingParams_PoolingType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

#ifndef _MSC_VER
const PoolingParams_PoolingType PoolingParams::MAX;
const PoolingParams_PoolingType PoolingParams::AVG;
const PoolingParams_PoolingType PoolingParams::PoolingType_MIN;
const PoolingParams_PoolingType PoolingParams::PoolingType_MAX;
const int PoolingParams::PoolingType_ARRAYSIZE;
#endif  // _MSC_VER
#ifndef _MSC_VER
const int PoolingParams::kTypeFieldNumber;
#endif  // !_MSC_VER

PoolingParams::PoolingParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void PoolingParams::InitAsDefaultInstance() {
}

PoolingParams::PoolingParams(const PoolingParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void PoolingParams::SharedCtor() {
  _cached_size_ = 0;
  type_ = 1;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

PoolingParams::~PoolingParams() {
  SharedDtor();
}

void PoolingParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void PoolingParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* PoolingParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PoolingParams_descriptor_;
}

const PoolingParams& PoolingParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

PoolingParams* PoolingParams::default_instance_ = NULL;

PoolingParams* PoolingParams::New() const {
  return new PoolingParams;
}

void PoolingParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 1;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool PoolingParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .PoolingParams.PoolingType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::PoolingParams_PoolingType_IsValid(value)) {
            set_type(static_cast< ::PoolingParams_PoolingType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void PoolingParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .PoolingParams.PoolingType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* PoolingParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .PoolingParams.PoolingType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int PoolingParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .PoolingParams.PoolingType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void PoolingParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const PoolingParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const PoolingParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void PoolingParams::MergeFrom(const PoolingParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void PoolingParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void PoolingParams::CopyFrom(const PoolingParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool PoolingParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void PoolingParams::Swap(PoolingParams* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata PoolingParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = PoolingParams_descriptor_;
  metadata.reflection = PoolingParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int SoftmaxParams::kOutputFieldNumber;
#endif  // !_MSC_VER

SoftmaxParams::SoftmaxParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void SoftmaxParams::InitAsDefaultInstance() {
}

SoftmaxParams::SoftmaxParams(const SoftmaxParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void SoftmaxParams::SharedCtor() {
  _cached_size_ = 0;
  output_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

SoftmaxParams::~SoftmaxParams() {
  SharedDtor();
}

void SoftmaxParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void SoftmaxParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SoftmaxParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SoftmaxParams_descriptor_;
}

const SoftmaxParams& SoftmaxParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

SoftmaxParams* SoftmaxParams::default_instance_ = NULL;

SoftmaxParams* SoftmaxParams::New() const {
  return new SoftmaxParams;
}

void SoftmaxParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    output_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool SoftmaxParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 output = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &output_)));
          set_has_output();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void SoftmaxParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 output = 1;
  if (has_output()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->output(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* SoftmaxParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 output = 1;
  if (has_output()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->output(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int SoftmaxParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 output = 1;
    if (has_output()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->output());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SoftmaxParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const SoftmaxParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const SoftmaxParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void SoftmaxParams::MergeFrom(const SoftmaxParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_output()) {
      set_output(from.output());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void SoftmaxParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SoftmaxParams::CopyFrom(const SoftmaxParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool SoftmaxParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void SoftmaxParams::Swap(SoftmaxParams* other) {
  if (other != this) {
    std::swap(output_, other->output_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata SoftmaxParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SoftmaxParams_descriptor_;
  metadata.reflection = SoftmaxParams_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int CrossEntropyParams::kOutputFieldNumber;
#endif  // !_MSC_VER

CrossEntropyParams::CrossEntropyParams()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void CrossEntropyParams::InitAsDefaultInstance() {
}

CrossEntropyParams::CrossEntropyParams(const CrossEntropyParams& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void CrossEntropyParams::SharedCtor() {
  _cached_size_ = 0;
  output_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

CrossEntropyParams::~CrossEntropyParams() {
  SharedDtor();
}

void CrossEntropyParams::SharedDtor() {
  if (this != default_instance_) {
  }
}

void CrossEntropyParams::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* CrossEntropyParams::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CrossEntropyParams_descriptor_;
}

const CrossEntropyParams& CrossEntropyParams::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_net_2eproto();
  return *default_instance_;
}

CrossEntropyParams* CrossEntropyParams::default_instance_ = NULL;

CrossEntropyParams* CrossEntropyParams::New() const {
  return new CrossEntropyParams;
}

void CrossEntropyParams::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    output_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool CrossEntropyParams::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required int32 output = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &output_)));
          set_has_output();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void CrossEntropyParams::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required int32 output = 1;
  if (has_output()) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->output(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* CrossEntropyParams::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required int32 output = 1;
  if (has_output()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->output(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int CrossEntropyParams::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required int32 output = 1;
    if (has_output()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::Int32Size(
          this->output());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void CrossEntropyParams::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const CrossEntropyParams* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const CrossEntropyParams*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void CrossEntropyParams::MergeFrom(const CrossEntropyParams& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_output()) {
      set_output(from.output());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void CrossEntropyParams::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void CrossEntropyParams::CopyFrom(const CrossEntropyParams& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CrossEntropyParams::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000001) != 0x00000001) return false;

  return true;
}

void CrossEntropyParams::Swap(CrossEntropyParams* other) {
  if (other != this) {
    std::swap(output_, other->output_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata CrossEntropyParams::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = CrossEntropyParams_descriptor_;
  metadata.reflection = CrossEntropyParams_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

// @@protoc_insertion_point(global_scope)

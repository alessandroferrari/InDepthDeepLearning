// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: net.proto

#ifndef PROTOBUF_net_2eproto__INCLUDED
#define PROTOBUF_net_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_net_2eproto();
void protobuf_AssignDesc_net_2eproto();
void protobuf_ShutdownFile_net_2eproto();

class NetParams;
class TensorParams;
class LayerParams;
class FullyConnectedParams;
class ConvolutionalParams;
class PoolingParams;
class SoftmaxParams;
class CrossEntropyParams;

enum LayerParams_LayerType {
  LayerParams_LayerType_FULLY_CONNECTED = 1,
  LayerParams_LayerType_RELU = 2,
  LayerParams_LayerType_SIGMOID = 3,
  LayerParams_LayerType_CONVOLUTIONAL = 4,
  LayerParams_LayerType_SOFTMAX_LOSS = 5,
  LayerParams_LayerType_CROSSENTROPY_LOSS = 6,
  LayerParams_LayerType_POOLING = 7
};
bool LayerParams_LayerType_IsValid(int value);
const LayerParams_LayerType LayerParams_LayerType_LayerType_MIN = LayerParams_LayerType_FULLY_CONNECTED;
const LayerParams_LayerType LayerParams_LayerType_LayerType_MAX = LayerParams_LayerType_POOLING;
const int LayerParams_LayerType_LayerType_ARRAYSIZE = LayerParams_LayerType_LayerType_MAX + 1;

const ::google::protobuf::EnumDescriptor* LayerParams_LayerType_descriptor();
inline const ::std::string& LayerParams_LayerType_Name(LayerParams_LayerType value) {
  return ::google::protobuf::internal::NameOfEnum(
    LayerParams_LayerType_descriptor(), value);
}
inline bool LayerParams_LayerType_Parse(
    const ::std::string& name, LayerParams_LayerType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LayerParams_LayerType>(
    LayerParams_LayerType_descriptor(), name, value);
}
enum PoolingParams_PoolingType {
  PoolingParams_PoolingType_MAX = 1,
  PoolingParams_PoolingType_AVG = 2
};
bool PoolingParams_PoolingType_IsValid(int value);
const PoolingParams_PoolingType PoolingParams_PoolingType_PoolingType_MIN = PoolingParams_PoolingType_MAX;
const PoolingParams_PoolingType PoolingParams_PoolingType_PoolingType_MAX = PoolingParams_PoolingType_AVG;
const int PoolingParams_PoolingType_PoolingType_ARRAYSIZE = PoolingParams_PoolingType_PoolingType_MAX + 1;

const ::google::protobuf::EnumDescriptor* PoolingParams_PoolingType_descriptor();
inline const ::std::string& PoolingParams_PoolingType_Name(PoolingParams_PoolingType value) {
  return ::google::protobuf::internal::NameOfEnum(
    PoolingParams_PoolingType_descriptor(), value);
}
inline bool PoolingParams_PoolingType_Parse(
    const ::std::string& name, PoolingParams_PoolingType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PoolingParams_PoolingType>(
    PoolingParams_PoolingType_descriptor(), name, value);
}
// ===================================================================

class NetParams : public ::google::protobuf::Message {
 public:
  NetParams();
  virtual ~NetParams();

  NetParams(const NetParams& from);

  inline NetParams& operator=(const NetParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NetParams& default_instance();

  void Swap(NetParams* other);

  // implements Message ----------------------------------------------

  NetParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NetParams& from);
  void MergeFrom(const NetParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .LayerParams layer = 1;
  inline int layer_size() const;
  inline void clear_layer();
  static const int kLayerFieldNumber = 1;
  inline const ::LayerParams& layer(int index) const;
  inline ::LayerParams* mutable_layer(int index);
  inline ::LayerParams* add_layer();
  inline const ::google::protobuf::RepeatedPtrField< ::LayerParams >&
      layer() const;
  inline ::google::protobuf::RepeatedPtrField< ::LayerParams >*
      mutable_layer();

  // @@protoc_insertion_point(class_scope:NetParams)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::LayerParams > layer_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static NetParams* default_instance_;
};
// -------------------------------------------------------------------

class TensorParams : public ::google::protobuf::Message {
 public:
  TensorParams();
  virtual ~TensorParams();

  TensorParams(const TensorParams& from);

  inline TensorParams& operator=(const TensorParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TensorParams& default_instance();

  void Swap(TensorParams* other);

  // implements Message ----------------------------------------------

  TensorParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TensorParams& from);
  void MergeFrom(const TensorParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated int32 shape = 1;
  inline int shape_size() const;
  inline void clear_shape();
  static const int kShapeFieldNumber = 1;
  inline ::google::protobuf::int32 shape(int index) const;
  inline void set_shape(int index, ::google::protobuf::int32 value);
  inline void add_shape(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      shape() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_shape();

  // repeated double weights = 2;
  inline int weights_size() const;
  inline void clear_weights();
  static const int kWeightsFieldNumber = 2;
  inline double weights(int index) const;
  inline void set_weights(int index, double value);
  inline void add_weights(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      weights() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_weights();

  // repeated double bias = 3;
  inline int bias_size() const;
  inline void clear_bias();
  static const int kBiasFieldNumber = 3;
  inline double bias(int index) const;
  inline void set_bias(int index, double value);
  inline void add_bias(double value);
  inline const ::google::protobuf::RepeatedField< double >&
      bias() const;
  inline ::google::protobuf::RepeatedField< double >*
      mutable_bias();

  // @@protoc_insertion_point(class_scope:TensorParams)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > shape_;
  ::google::protobuf::RepeatedField< double > weights_;
  ::google::protobuf::RepeatedField< double > bias_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static TensorParams* default_instance_;
};
// -------------------------------------------------------------------

class LayerParams : public ::google::protobuf::Message {
 public:
  LayerParams();
  virtual ~LayerParams();

  LayerParams(const LayerParams& from);

  inline LayerParams& operator=(const LayerParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const LayerParams& default_instance();

  void Swap(LayerParams* other);

  // implements Message ----------------------------------------------

  LayerParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const LayerParams& from);
  void MergeFrom(const LayerParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef LayerParams_LayerType LayerType;
  static const LayerType FULLY_CONNECTED = LayerParams_LayerType_FULLY_CONNECTED;
  static const LayerType RELU = LayerParams_LayerType_RELU;
  static const LayerType SIGMOID = LayerParams_LayerType_SIGMOID;
  static const LayerType CONVOLUTIONAL = LayerParams_LayerType_CONVOLUTIONAL;
  static const LayerType SOFTMAX_LOSS = LayerParams_LayerType_SOFTMAX_LOSS;
  static const LayerType CROSSENTROPY_LOSS = LayerParams_LayerType_CROSSENTROPY_LOSS;
  static const LayerType POOLING = LayerParams_LayerType_POOLING;
  static inline bool LayerType_IsValid(int value) {
    return LayerParams_LayerType_IsValid(value);
  }
  static const LayerType LayerType_MIN =
    LayerParams_LayerType_LayerType_MIN;
  static const LayerType LayerType_MAX =
    LayerParams_LayerType_LayerType_MAX;
  static const int LayerType_ARRAYSIZE =
    LayerParams_LayerType_LayerType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  LayerType_descriptor() {
    return LayerParams_LayerType_descriptor();
  }
  static inline const ::std::string& LayerType_Name(LayerType value) {
    return LayerParams_LayerType_Name(value);
  }
  static inline bool LayerType_Parse(const ::std::string& name,
      LayerType* value) {
    return LayerParams_LayerType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string bottom = 2;
  inline bool has_bottom() const;
  inline void clear_bottom();
  static const int kBottomFieldNumber = 2;
  inline const ::std::string& bottom() const;
  inline void set_bottom(const ::std::string& value);
  inline void set_bottom(const char* value);
  inline void set_bottom(const char* value, size_t size);
  inline ::std::string* mutable_bottom();
  inline ::std::string* release_bottom();
  inline void set_allocated_bottom(::std::string* bottom);

  // required string top = 3;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 3;
  inline const ::std::string& top() const;
  inline void set_top(const ::std::string& value);
  inline void set_top(const char* value);
  inline void set_top(const char* value, size_t size);
  inline ::std::string* mutable_top();
  inline ::std::string* release_top();
  inline void set_allocated_top(::std::string* top);

  // required .LayerParams.LayerType type = 4;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 4;
  inline ::LayerParams_LayerType type() const;
  inline void set_type(::LayerParams_LayerType value);

  // repeated .TensorParams weights = 5;
  inline int weights_size() const;
  inline void clear_weights();
  static const int kWeightsFieldNumber = 5;
  inline const ::TensorParams& weights(int index) const;
  inline ::TensorParams* mutable_weights(int index);
  inline ::TensorParams* add_weights();
  inline const ::google::protobuf::RepeatedPtrField< ::TensorParams >&
      weights() const;
  inline ::google::protobuf::RepeatedPtrField< ::TensorParams >*
      mutable_weights();

  // optional .FullyConnectedParams fully_connected_params = 6;
  inline bool has_fully_connected_params() const;
  inline void clear_fully_connected_params();
  static const int kFullyConnectedParamsFieldNumber = 6;
  inline const ::FullyConnectedParams& fully_connected_params() const;
  inline ::FullyConnectedParams* mutable_fully_connected_params();
  inline ::FullyConnectedParams* release_fully_connected_params();
  inline void set_allocated_fully_connected_params(::FullyConnectedParams* fully_connected_params);

  // optional .ConvolutionalParams convolutional_params = 7;
  inline bool has_convolutional_params() const;
  inline void clear_convolutional_params();
  static const int kConvolutionalParamsFieldNumber = 7;
  inline const ::ConvolutionalParams& convolutional_params() const;
  inline ::ConvolutionalParams* mutable_convolutional_params();
  inline ::ConvolutionalParams* release_convolutional_params();
  inline void set_allocated_convolutional_params(::ConvolutionalParams* convolutional_params);

  // optional .PoolingParams pooling_params = 8;
  inline bool has_pooling_params() const;
  inline void clear_pooling_params();
  static const int kPoolingParamsFieldNumber = 8;
  inline const ::PoolingParams& pooling_params() const;
  inline ::PoolingParams* mutable_pooling_params();
  inline ::PoolingParams* release_pooling_params();
  inline void set_allocated_pooling_params(::PoolingParams* pooling_params);

  // optional .SoftmaxParams softmax_params = 9;
  inline bool has_softmax_params() const;
  inline void clear_softmax_params();
  static const int kSoftmaxParamsFieldNumber = 9;
  inline const ::SoftmaxParams& softmax_params() const;
  inline ::SoftmaxParams* mutable_softmax_params();
  inline ::SoftmaxParams* release_softmax_params();
  inline void set_allocated_softmax_params(::SoftmaxParams* softmax_params);

  // optional .CrossEntropyParams cross_entropy_params = 10;
  inline bool has_cross_entropy_params() const;
  inline void clear_cross_entropy_params();
  static const int kCrossEntropyParamsFieldNumber = 10;
  inline const ::CrossEntropyParams& cross_entropy_params() const;
  inline ::CrossEntropyParams* mutable_cross_entropy_params();
  inline ::CrossEntropyParams* release_cross_entropy_params();
  inline void set_allocated_cross_entropy_params(::CrossEntropyParams* cross_entropy_params);

  // @@protoc_insertion_point(class_scope:LayerParams)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_bottom();
  inline void clear_has_bottom();
  inline void set_has_top();
  inline void clear_has_top();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_fully_connected_params();
  inline void clear_has_fully_connected_params();
  inline void set_has_convolutional_params();
  inline void clear_has_convolutional_params();
  inline void set_has_pooling_params();
  inline void clear_has_pooling_params();
  inline void set_has_softmax_params();
  inline void clear_has_softmax_params();
  inline void set_has_cross_entropy_params();
  inline void clear_has_cross_entropy_params();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* bottom_;
  ::std::string* top_;
  ::google::protobuf::RepeatedPtrField< ::TensorParams > weights_;
  ::FullyConnectedParams* fully_connected_params_;
  ::ConvolutionalParams* convolutional_params_;
  ::PoolingParams* pooling_params_;
  ::SoftmaxParams* softmax_params_;
  ::CrossEntropyParams* cross_entropy_params_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static LayerParams* default_instance_;
};
// -------------------------------------------------------------------

class FullyConnectedParams : public ::google::protobuf::Message {
 public:
  FullyConnectedParams();
  virtual ~FullyConnectedParams();

  FullyConnectedParams(const FullyConnectedParams& from);

  inline FullyConnectedParams& operator=(const FullyConnectedParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FullyConnectedParams& default_instance();

  void Swap(FullyConnectedParams* other);

  // implements Message ----------------------------------------------

  FullyConnectedParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FullyConnectedParams& from);
  void MergeFrom(const FullyConnectedParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 output = 1;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 1;
  inline ::google::protobuf::int32 output() const;
  inline void set_output(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:FullyConnectedParams)
 private:
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static FullyConnectedParams* default_instance_;
};
// -------------------------------------------------------------------

class ConvolutionalParams : public ::google::protobuf::Message {
 public:
  ConvolutionalParams();
  virtual ~ConvolutionalParams();

  ConvolutionalParams(const ConvolutionalParams& from);

  inline ConvolutionalParams& operator=(const ConvolutionalParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ConvolutionalParams& default_instance();

  void Swap(ConvolutionalParams* other);

  // implements Message ----------------------------------------------

  ConvolutionalParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ConvolutionalParams& from);
  void MergeFrom(const ConvolutionalParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 kernel_size = 1;
  inline bool has_kernel_size() const;
  inline void clear_kernel_size();
  static const int kKernelSizeFieldNumber = 1;
  inline ::google::protobuf::int32 kernel_size() const;
  inline void set_kernel_size(::google::protobuf::int32 value);

  // required int32 stride = 2;
  inline bool has_stride() const;
  inline void clear_stride();
  static const int kStrideFieldNumber = 2;
  inline ::google::protobuf::int32 stride() const;
  inline void set_stride(::google::protobuf::int32 value);

  // required int32 features_maps = 3;
  inline bool has_features_maps() const;
  inline void clear_features_maps();
  static const int kFeaturesMapsFieldNumber = 3;
  inline ::google::protobuf::int32 features_maps() const;
  inline void set_features_maps(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:ConvolutionalParams)
 private:
  inline void set_has_kernel_size();
  inline void clear_has_kernel_size();
  inline void set_has_stride();
  inline void clear_has_stride();
  inline void set_has_features_maps();
  inline void clear_has_features_maps();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 kernel_size_;
  ::google::protobuf::int32 stride_;
  ::google::protobuf::int32 features_maps_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static ConvolutionalParams* default_instance_;
};
// -------------------------------------------------------------------

class PoolingParams : public ::google::protobuf::Message {
 public:
  PoolingParams();
  virtual ~PoolingParams();

  PoolingParams(const PoolingParams& from);

  inline PoolingParams& operator=(const PoolingParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const PoolingParams& default_instance();

  void Swap(PoolingParams* other);

  // implements Message ----------------------------------------------

  PoolingParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const PoolingParams& from);
  void MergeFrom(const PoolingParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef PoolingParams_PoolingType PoolingType;
  static const PoolingType MAX = PoolingParams_PoolingType_MAX;
  static const PoolingType AVG = PoolingParams_PoolingType_AVG;
  static inline bool PoolingType_IsValid(int value) {
    return PoolingParams_PoolingType_IsValid(value);
  }
  static const PoolingType PoolingType_MIN =
    PoolingParams_PoolingType_PoolingType_MIN;
  static const PoolingType PoolingType_MAX =
    PoolingParams_PoolingType_PoolingType_MAX;
  static const int PoolingType_ARRAYSIZE =
    PoolingParams_PoolingType_PoolingType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  PoolingType_descriptor() {
    return PoolingParams_PoolingType_descriptor();
  }
  static inline const ::std::string& PoolingType_Name(PoolingType value) {
    return PoolingParams_PoolingType_Name(value);
  }
  static inline bool PoolingType_Parse(const ::std::string& name,
      PoolingType* value) {
    return PoolingParams_PoolingType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .PoolingParams.PoolingType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::PoolingParams_PoolingType type() const;
  inline void set_type(::PoolingParams_PoolingType value);

  // @@protoc_insertion_point(class_scope:PoolingParams)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static PoolingParams* default_instance_;
};
// -------------------------------------------------------------------

class SoftmaxParams : public ::google::protobuf::Message {
 public:
  SoftmaxParams();
  virtual ~SoftmaxParams();

  SoftmaxParams(const SoftmaxParams& from);

  inline SoftmaxParams& operator=(const SoftmaxParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SoftmaxParams& default_instance();

  void Swap(SoftmaxParams* other);

  // implements Message ----------------------------------------------

  SoftmaxParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SoftmaxParams& from);
  void MergeFrom(const SoftmaxParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 output = 1;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 1;
  inline ::google::protobuf::int32 output() const;
  inline void set_output(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:SoftmaxParams)
 private:
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static SoftmaxParams* default_instance_;
};
// -------------------------------------------------------------------

class CrossEntropyParams : public ::google::protobuf::Message {
 public:
  CrossEntropyParams();
  virtual ~CrossEntropyParams();

  CrossEntropyParams(const CrossEntropyParams& from);

  inline CrossEntropyParams& operator=(const CrossEntropyParams& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CrossEntropyParams& default_instance();

  void Swap(CrossEntropyParams* other);

  // implements Message ----------------------------------------------

  CrossEntropyParams* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CrossEntropyParams& from);
  void MergeFrom(const CrossEntropyParams& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 output = 1;
  inline bool has_output() const;
  inline void clear_output();
  static const int kOutputFieldNumber = 1;
  inline ::google::protobuf::int32 output() const;
  inline void set_output(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CrossEntropyParams)
 private:
  inline void set_has_output();
  inline void clear_has_output();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 output_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_net_2eproto();
  friend void protobuf_AssignDesc_net_2eproto();
  friend void protobuf_ShutdownFile_net_2eproto();

  void InitAsDefaultInstance();
  static CrossEntropyParams* default_instance_;
};
// ===================================================================


// ===================================================================

// NetParams

// repeated .LayerParams layer = 1;
inline int NetParams::layer_size() const {
  return layer_.size();
}
inline void NetParams::clear_layer() {
  layer_.Clear();
}
inline const ::LayerParams& NetParams::layer(int index) const {
  return layer_.Get(index);
}
inline ::LayerParams* NetParams::mutable_layer(int index) {
  return layer_.Mutable(index);
}
inline ::LayerParams* NetParams::add_layer() {
  return layer_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::LayerParams >&
NetParams::layer() const {
  return layer_;
}
inline ::google::protobuf::RepeatedPtrField< ::LayerParams >*
NetParams::mutable_layer() {
  return &layer_;
}

// -------------------------------------------------------------------

// TensorParams

// repeated int32 shape = 1;
inline int TensorParams::shape_size() const {
  return shape_.size();
}
inline void TensorParams::clear_shape() {
  shape_.Clear();
}
inline ::google::protobuf::int32 TensorParams::shape(int index) const {
  return shape_.Get(index);
}
inline void TensorParams::set_shape(int index, ::google::protobuf::int32 value) {
  shape_.Set(index, value);
}
inline void TensorParams::add_shape(::google::protobuf::int32 value) {
  shape_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
TensorParams::shape() const {
  return shape_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
TensorParams::mutable_shape() {
  return &shape_;
}

// repeated double weights = 2;
inline int TensorParams::weights_size() const {
  return weights_.size();
}
inline void TensorParams::clear_weights() {
  weights_.Clear();
}
inline double TensorParams::weights(int index) const {
  return weights_.Get(index);
}
inline void TensorParams::set_weights(int index, double value) {
  weights_.Set(index, value);
}
inline void TensorParams::add_weights(double value) {
  weights_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
TensorParams::weights() const {
  return weights_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorParams::mutable_weights() {
  return &weights_;
}

// repeated double bias = 3;
inline int TensorParams::bias_size() const {
  return bias_.size();
}
inline void TensorParams::clear_bias() {
  bias_.Clear();
}
inline double TensorParams::bias(int index) const {
  return bias_.Get(index);
}
inline void TensorParams::set_bias(int index, double value) {
  bias_.Set(index, value);
}
inline void TensorParams::add_bias(double value) {
  bias_.Add(value);
}
inline const ::google::protobuf::RepeatedField< double >&
TensorParams::bias() const {
  return bias_;
}
inline ::google::protobuf::RepeatedField< double >*
TensorParams::mutable_bias() {
  return &bias_;
}

// -------------------------------------------------------------------

// LayerParams

// required string name = 1;
inline bool LayerParams::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayerParams::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayerParams::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayerParams::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LayerParams::name() const {
  return *name_;
}
inline void LayerParams::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParams::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LayerParams::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParams::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LayerParams::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParams::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string bottom = 2;
inline bool LayerParams::has_bottom() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayerParams::set_has_bottom() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayerParams::clear_has_bottom() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayerParams::clear_bottom() {
  if (bottom_ != &::google::protobuf::internal::kEmptyString) {
    bottom_->clear();
  }
  clear_has_bottom();
}
inline const ::std::string& LayerParams::bottom() const {
  return *bottom_;
}
inline void LayerParams::set_bottom(const ::std::string& value) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(value);
}
inline void LayerParams::set_bottom(const char* value) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(value);
}
inline void LayerParams::set_bottom(const char* value, size_t size) {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  bottom_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParams::mutable_bottom() {
  set_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    bottom_ = new ::std::string;
  }
  return bottom_;
}
inline ::std::string* LayerParams::release_bottom() {
  clear_has_bottom();
  if (bottom_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = bottom_;
    bottom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParams::set_allocated_bottom(::std::string* bottom) {
  if (bottom_ != &::google::protobuf::internal::kEmptyString) {
    delete bottom_;
  }
  if (bottom) {
    set_has_bottom();
    bottom_ = bottom;
  } else {
    clear_has_bottom();
    bottom_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string top = 3;
inline bool LayerParams::has_top() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayerParams::set_has_top() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayerParams::clear_has_top() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayerParams::clear_top() {
  if (top_ != &::google::protobuf::internal::kEmptyString) {
    top_->clear();
  }
  clear_has_top();
}
inline const ::std::string& LayerParams::top() const {
  return *top_;
}
inline void LayerParams::set_top(const ::std::string& value) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void LayerParams::set_top(const char* value) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(value);
}
inline void LayerParams::set_top(const char* value, size_t size) {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  top_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayerParams::mutable_top() {
  set_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    top_ = new ::std::string;
  }
  return top_;
}
inline ::std::string* LayerParams::release_top() {
  clear_has_top();
  if (top_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = top_;
    top_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayerParams::set_allocated_top(::std::string* top) {
  if (top_ != &::google::protobuf::internal::kEmptyString) {
    delete top_;
  }
  if (top) {
    set_has_top();
    top_ = top;
  } else {
    clear_has_top();
    top_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .LayerParams.LayerType type = 4;
inline bool LayerParams::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayerParams::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayerParams::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayerParams::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::LayerParams_LayerType LayerParams::type() const {
  return static_cast< ::LayerParams_LayerType >(type_);
}
inline void LayerParams::set_type(::LayerParams_LayerType value) {
  assert(::LayerParams_LayerType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .TensorParams weights = 5;
inline int LayerParams::weights_size() const {
  return weights_.size();
}
inline void LayerParams::clear_weights() {
  weights_.Clear();
}
inline const ::TensorParams& LayerParams::weights(int index) const {
  return weights_.Get(index);
}
inline ::TensorParams* LayerParams::mutable_weights(int index) {
  return weights_.Mutable(index);
}
inline ::TensorParams* LayerParams::add_weights() {
  return weights_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::TensorParams >&
LayerParams::weights() const {
  return weights_;
}
inline ::google::protobuf::RepeatedPtrField< ::TensorParams >*
LayerParams::mutable_weights() {
  return &weights_;
}

// optional .FullyConnectedParams fully_connected_params = 6;
inline bool LayerParams::has_fully_connected_params() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayerParams::set_has_fully_connected_params() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayerParams::clear_has_fully_connected_params() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayerParams::clear_fully_connected_params() {
  if (fully_connected_params_ != NULL) fully_connected_params_->::FullyConnectedParams::Clear();
  clear_has_fully_connected_params();
}
inline const ::FullyConnectedParams& LayerParams::fully_connected_params() const {
  return fully_connected_params_ != NULL ? *fully_connected_params_ : *default_instance_->fully_connected_params_;
}
inline ::FullyConnectedParams* LayerParams::mutable_fully_connected_params() {
  set_has_fully_connected_params();
  if (fully_connected_params_ == NULL) fully_connected_params_ = new ::FullyConnectedParams;
  return fully_connected_params_;
}
inline ::FullyConnectedParams* LayerParams::release_fully_connected_params() {
  clear_has_fully_connected_params();
  ::FullyConnectedParams* temp = fully_connected_params_;
  fully_connected_params_ = NULL;
  return temp;
}
inline void LayerParams::set_allocated_fully_connected_params(::FullyConnectedParams* fully_connected_params) {
  delete fully_connected_params_;
  fully_connected_params_ = fully_connected_params;
  if (fully_connected_params) {
    set_has_fully_connected_params();
  } else {
    clear_has_fully_connected_params();
  }
}

// optional .ConvolutionalParams convolutional_params = 7;
inline bool LayerParams::has_convolutional_params() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayerParams::set_has_convolutional_params() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayerParams::clear_has_convolutional_params() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayerParams::clear_convolutional_params() {
  if (convolutional_params_ != NULL) convolutional_params_->::ConvolutionalParams::Clear();
  clear_has_convolutional_params();
}
inline const ::ConvolutionalParams& LayerParams::convolutional_params() const {
  return convolutional_params_ != NULL ? *convolutional_params_ : *default_instance_->convolutional_params_;
}
inline ::ConvolutionalParams* LayerParams::mutable_convolutional_params() {
  set_has_convolutional_params();
  if (convolutional_params_ == NULL) convolutional_params_ = new ::ConvolutionalParams;
  return convolutional_params_;
}
inline ::ConvolutionalParams* LayerParams::release_convolutional_params() {
  clear_has_convolutional_params();
  ::ConvolutionalParams* temp = convolutional_params_;
  convolutional_params_ = NULL;
  return temp;
}
inline void LayerParams::set_allocated_convolutional_params(::ConvolutionalParams* convolutional_params) {
  delete convolutional_params_;
  convolutional_params_ = convolutional_params;
  if (convolutional_params) {
    set_has_convolutional_params();
  } else {
    clear_has_convolutional_params();
  }
}

// optional .PoolingParams pooling_params = 8;
inline bool LayerParams::has_pooling_params() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayerParams::set_has_pooling_params() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayerParams::clear_has_pooling_params() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayerParams::clear_pooling_params() {
  if (pooling_params_ != NULL) pooling_params_->::PoolingParams::Clear();
  clear_has_pooling_params();
}
inline const ::PoolingParams& LayerParams::pooling_params() const {
  return pooling_params_ != NULL ? *pooling_params_ : *default_instance_->pooling_params_;
}
inline ::PoolingParams* LayerParams::mutable_pooling_params() {
  set_has_pooling_params();
  if (pooling_params_ == NULL) pooling_params_ = new ::PoolingParams;
  return pooling_params_;
}
inline ::PoolingParams* LayerParams::release_pooling_params() {
  clear_has_pooling_params();
  ::PoolingParams* temp = pooling_params_;
  pooling_params_ = NULL;
  return temp;
}
inline void LayerParams::set_allocated_pooling_params(::PoolingParams* pooling_params) {
  delete pooling_params_;
  pooling_params_ = pooling_params;
  if (pooling_params) {
    set_has_pooling_params();
  } else {
    clear_has_pooling_params();
  }
}

// optional .SoftmaxParams softmax_params = 9;
inline bool LayerParams::has_softmax_params() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayerParams::set_has_softmax_params() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayerParams::clear_has_softmax_params() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayerParams::clear_softmax_params() {
  if (softmax_params_ != NULL) softmax_params_->::SoftmaxParams::Clear();
  clear_has_softmax_params();
}
inline const ::SoftmaxParams& LayerParams::softmax_params() const {
  return softmax_params_ != NULL ? *softmax_params_ : *default_instance_->softmax_params_;
}
inline ::SoftmaxParams* LayerParams::mutable_softmax_params() {
  set_has_softmax_params();
  if (softmax_params_ == NULL) softmax_params_ = new ::SoftmaxParams;
  return softmax_params_;
}
inline ::SoftmaxParams* LayerParams::release_softmax_params() {
  clear_has_softmax_params();
  ::SoftmaxParams* temp = softmax_params_;
  softmax_params_ = NULL;
  return temp;
}
inline void LayerParams::set_allocated_softmax_params(::SoftmaxParams* softmax_params) {
  delete softmax_params_;
  softmax_params_ = softmax_params;
  if (softmax_params) {
    set_has_softmax_params();
  } else {
    clear_has_softmax_params();
  }
}

// optional .CrossEntropyParams cross_entropy_params = 10;
inline bool LayerParams::has_cross_entropy_params() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayerParams::set_has_cross_entropy_params() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayerParams::clear_has_cross_entropy_params() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayerParams::clear_cross_entropy_params() {
  if (cross_entropy_params_ != NULL) cross_entropy_params_->::CrossEntropyParams::Clear();
  clear_has_cross_entropy_params();
}
inline const ::CrossEntropyParams& LayerParams::cross_entropy_params() const {
  return cross_entropy_params_ != NULL ? *cross_entropy_params_ : *default_instance_->cross_entropy_params_;
}
inline ::CrossEntropyParams* LayerParams::mutable_cross_entropy_params() {
  set_has_cross_entropy_params();
  if (cross_entropy_params_ == NULL) cross_entropy_params_ = new ::CrossEntropyParams;
  return cross_entropy_params_;
}
inline ::CrossEntropyParams* LayerParams::release_cross_entropy_params() {
  clear_has_cross_entropy_params();
  ::CrossEntropyParams* temp = cross_entropy_params_;
  cross_entropy_params_ = NULL;
  return temp;
}
inline void LayerParams::set_allocated_cross_entropy_params(::CrossEntropyParams* cross_entropy_params) {
  delete cross_entropy_params_;
  cross_entropy_params_ = cross_entropy_params;
  if (cross_entropy_params) {
    set_has_cross_entropy_params();
  } else {
    clear_has_cross_entropy_params();
  }
}

// -------------------------------------------------------------------

// FullyConnectedParams

// required int32 output = 1;
inline bool FullyConnectedParams::has_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FullyConnectedParams::set_has_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FullyConnectedParams::clear_has_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FullyConnectedParams::clear_output() {
  output_ = 0;
  clear_has_output();
}
inline ::google::protobuf::int32 FullyConnectedParams::output() const {
  return output_;
}
inline void FullyConnectedParams::set_output(::google::protobuf::int32 value) {
  set_has_output();
  output_ = value;
}

// -------------------------------------------------------------------

// ConvolutionalParams

// required int32 kernel_size = 1;
inline bool ConvolutionalParams::has_kernel_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ConvolutionalParams::set_has_kernel_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ConvolutionalParams::clear_has_kernel_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ConvolutionalParams::clear_kernel_size() {
  kernel_size_ = 0;
  clear_has_kernel_size();
}
inline ::google::protobuf::int32 ConvolutionalParams::kernel_size() const {
  return kernel_size_;
}
inline void ConvolutionalParams::set_kernel_size(::google::protobuf::int32 value) {
  set_has_kernel_size();
  kernel_size_ = value;
}

// required int32 stride = 2;
inline bool ConvolutionalParams::has_stride() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ConvolutionalParams::set_has_stride() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ConvolutionalParams::clear_has_stride() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ConvolutionalParams::clear_stride() {
  stride_ = 0;
  clear_has_stride();
}
inline ::google::protobuf::int32 ConvolutionalParams::stride() const {
  return stride_;
}
inline void ConvolutionalParams::set_stride(::google::protobuf::int32 value) {
  set_has_stride();
  stride_ = value;
}

// required int32 features_maps = 3;
inline bool ConvolutionalParams::has_features_maps() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ConvolutionalParams::set_has_features_maps() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ConvolutionalParams::clear_has_features_maps() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ConvolutionalParams::clear_features_maps() {
  features_maps_ = 0;
  clear_has_features_maps();
}
inline ::google::protobuf::int32 ConvolutionalParams::features_maps() const {
  return features_maps_;
}
inline void ConvolutionalParams::set_features_maps(::google::protobuf::int32 value) {
  set_has_features_maps();
  features_maps_ = value;
}

// -------------------------------------------------------------------

// PoolingParams

// required .PoolingParams.PoolingType type = 1;
inline bool PoolingParams::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PoolingParams::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PoolingParams::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PoolingParams::clear_type() {
  type_ = 1;
  clear_has_type();
}
inline ::PoolingParams_PoolingType PoolingParams::type() const {
  return static_cast< ::PoolingParams_PoolingType >(type_);
}
inline void PoolingParams::set_type(::PoolingParams_PoolingType value) {
  assert(::PoolingParams_PoolingType_IsValid(value));
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// SoftmaxParams

// required int32 output = 1;
inline bool SoftmaxParams::has_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SoftmaxParams::set_has_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SoftmaxParams::clear_has_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SoftmaxParams::clear_output() {
  output_ = 0;
  clear_has_output();
}
inline ::google::protobuf::int32 SoftmaxParams::output() const {
  return output_;
}
inline void SoftmaxParams::set_output(::google::protobuf::int32 value) {
  set_has_output();
  output_ = value;
}

// -------------------------------------------------------------------

// CrossEntropyParams

// required int32 output = 1;
inline bool CrossEntropyParams::has_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CrossEntropyParams::set_has_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CrossEntropyParams::clear_has_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CrossEntropyParams::clear_output() {
  output_ = 0;
  clear_has_output();
}
inline ::google::protobuf::int32 CrossEntropyParams::output() const {
  return output_;
}
inline void CrossEntropyParams::set_output(::google::protobuf::int32 value) {
  set_has_output();
  output_ = value;
}


// @@protoc_insertion_point(namespace_scope)

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::LayerParams_LayerType>() {
  return ::LayerParams_LayerType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::PoolingParams_PoolingType>() {
  return ::PoolingParams_PoolingType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_net_2eproto__INCLUDED
